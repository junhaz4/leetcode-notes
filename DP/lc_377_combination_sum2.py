class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        # 从nums中选择一些数，这些数的和等于target，每个数都可以用多次，所以是完全背包问题
        #（1,1,2）和(1,2,1)是不同的结果，说明本题求得不是组合，而是排列数
        # dp[j]表示组成和为j的排列数
        # 递推公式，不用nums[i]->dp[j], 用nums[i]->dp[j-nums[i]]
        # 初始化，dp[0]=1本身没有意义，仅为了递推使用
        # 如果求组合数就是外层for循环遍历物品，内层for遍历背包
            # 外层循环的顺序是先固定一个物品，再遍历背包容量。每次遍历到一个容量 j 时，只考虑前 i 个物品的选法。
            # 由于是“先选物品，再扩充组合”，所有物品的选择“顺序”在逻辑上是固定的，不会因为后面物品的加入导致排列方式不同。
        # 如果求排列数就是外层for遍历背包，内层for循环遍历物品。
            # 外层遍历背包容量，意味着每次针对一个容量，都去尝试用所有物品填充这一容量
            # 内层遍历物品，在考虑 j 的所有可能组合时会重新尝试每一个物品，使得组合的顺序不同会被全部记录。
        # 所以本题遍历顺序最终遍历顺序：target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历。
        n = len(nums)
        dp = [0]*(target+1)
        dp[0] = 1  # 初始化背包容量为0时的组合总数为1
        for j in range(1,target+1): # 变量容量
            for n in nums: # 遍历数组
                if j >= n: # 当背包容量大于等于当前物品重量时
                    dp[j] = dp[j] + dp[j-n] # # 更新组合总数
        return dp[target]

        # 思路二，爬楼梯
        # 总共需要爬上target高度的楼梯，每次能走的距离就是nums[i],求总共多少种做法
        


