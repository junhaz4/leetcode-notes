# 01背包理论基础

**问题定义**：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大

举例：背包最大重量为4， weights = [1, 3, 4], values = [15, 20, 30], 问背包能背的物品最大价值是多少？

暴力解法：每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是O(2^n)，这里的n表示物品数量。

## **动态规划**：
1. 确定dp数组以及下标的含义
   需要使用二维数组，因为涉及到两个维度，物品和背包容量
   ```dp[i][j]``` 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
2. 确定递推公式
   1. 以dp[1][4]的状态来举例，这里有两种情况：放物品1或者不放物品1
      1. 如果不放物品1，那么背包的价值应该是 dp[0][4] 即容量为4的背包，只放物品0的情况，
      2. 如果放物品1， 那么背包要先留出物品1的容量，目前容量是4，物品1 的容量（就是物品1的重量）为3，此时背包剩下容量为1。容量为1，只考虑放物品0 的最大价值是 dp[0][1]，所以 放物品1 的情况 = dp[0][1] + 物品1 的价值
      3. 两种情况，分别是放物品1 和 不放物品1，我们要取最大值（毕竟求的是最大价值），所以dp[1][4] = max(dp[0][4], dp[0][1] + 物品1 的价值)
   2. 不放物品i：即从0~i-1的物品中任意取，放进容量为j的背包，最大价值总和就是```dp[i - 1][j]```，此时```dp[i][j]```就是```dp[i - 1][j]```(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)
   3. 放物品i：背包空出物品i的容量后，背包容量为```j - weight[i]```，然后从0~i-1的物品中任意取，放进容量为```j - weight[i]```的背包，```dp[i - 1][j - weight[i]]``` 为背包容量为```j - weight[i]```且不放物品i的最大价值总和，那么```dp[i][j] = dp[i - 1][j - weight[i]] + value[i]（i的价值）```
   所以递归公式：**dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])**
3. dp数组如何初始化
   关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱
   1. 首先从```dp[i][j]```的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0
   2. 状态转移方程 ```dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])```可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化，dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。那么很明显当 j < weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。当j >= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品
   ```python
   for i in range(weight[0],bagweight+1):
       dp[0][i] = value[0]
   ```
4. 确定遍历顺序
   有两个遍历的维度：物品和背包重量，两种遍历顺序都可以
   1. 先遍历物品，再遍历背包容量
   ```python
   for i in range(1,len(weight)): # 遍历物品
       for j in range(bagweight+1): # 遍历背包容量
           if weight[i] > j: # 如果当前物品重量大于背包容量，则不装入背包
               dp[i][j] = dp[i-1][j]
           else: # 如果当前物品重量小于背包容量，则比较两种情况：不装入背包和装入背包
               dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])
   ```
   2. 先遍历背包容量，再遍历物品
   ```python
   for j in range(bagweight+1): # 遍历背包容量
       for i in range(1,len(weight)): # 遍历物品
           if weight[i] > j: # 如果当前物品重量大于背包容量，则不装入背包
               dp[i][j] = dp[i-1][j]
           else: # 如果当前物品重量小于背包容量，则比较两种情况：不装入背包和装入背包
               dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])
   ```
   3. 为什么两种遍历都行? 因为dp[i][j]是根据dp[i-1][j]和dp[i - 1][j - weight[i]]推导出来的，是从左上角方向遍历而来的，虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！
   4. **其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了**
   
## **优化（滚动数组）**：
思考: 根据递推公式发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是:```dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])```
与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。
这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。
1. 确定dp数组以及下标的含义
   dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]
2. 确定递推公式
   一维dp数组就是把上一层dp[i-1]拷贝到dp[i]，所以在上面递推公式的基础上，去掉i这个维度就好。递推公式为：```dp[j] = max(dp[j], dp[j - weight[i]] + value[i])```
3. dp数组如何初始化
   **关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。**
   dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。
4. 确定遍历顺序
   ```python
   for i in range(len(weight)): #  应该先遍历物品，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品
       for j in range(bagweight,weight[i]-1,-1):  # 倒序遍历背包容量是为了保证物品i只被放入一次
           dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) # 递推公式
   ```
   这里的遍历顺序和二维dp的写法中是不一样的！二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。
   **倒序遍历是为了保证物品i只被放入一次**。但如果一旦正序遍历了，那么物品0就会被重复加入多次！
   举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15
   如果正序遍历，那么```dp[1] = dp[1 - weight[0]] + value[0] = 15```, ```dp[2] = dp[2 - weight[0]] + value[0] = 30```，此时dp[2]就已经是30了，物品0被重复放入了背包两次，dp[2]在计算的时候使用了dp[1]的结果，所以就是15 + 15 = 30了，重叠了，所以不能正序遍历
   对于01背包来说，更新dp[i]的值需要的是当前dp[i]和上一个状态的dp[i-w]，即**头顶上那个位置和左上角某个位置**，若是正序，dp[i-w]就更新过了，也就不是上一个状态的值了，所以必须逆序，
   就会先计算dp[2] ```dp[2] = dp[2 - weight[0]] + value[0] = 15``` （dp数组已经都初始化为0），然后才是dp[1]```dp[1] = dp[1 - weight[0]] + value[0] = 15```，从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。
   若是完全背包，更新dp[i]的值需要的是当前d[i]和当前状态的dp[i-w]，需要的就是更新过的值，所以正序是没问题的
   **那么问题又来了，为什么二维dp数组遍历的时候不用倒序呢？**
   因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！
   **再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？** 
   答案是不可以，因为一维dp的写法，背包容量一定是要倒序遍历，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，比如当i=bagweight进行循环的时候，里层的for循环会遍历每一个物品，那么dp[i]就会取所有单个物品的最大值，而不会去取组合的最大值，这样就错了。
   所以要做的是先遍历物品，再倒序遍历背包容量（用物品0遍历背包->用物品1遍历背包->用物品2遍历背包->...）

# 完全背包理论基础

**问题定义**：有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**

举例：背包最大重量为4， weights = [1, 3, 4], values = [15, 20, 30], 问背包能背的物品最大价值是多少？**每件商品都有无限个！**

## **动态规划**：
1. 确定dp数组以及下标的含义
   ```dp[i][j]```表示从下标为[0-i]的物品，每个物品可以取无限次，放进容量为j的背包，价值总和最大是多少
2. 确定递推公式
   1. 还是以dp[1][4]的状态举例，这里有两种情况：放物品1或者不放物品1
      1. 不放物品1，那么背包的价值应该是 dp[0][4] 即 容量为4的背包，只放物品0的情况，即dp[0][4]
      2. 放物品1，那么背包首先要留出物品1的容量，目前容量是4，物品1的容量是3，此时背包还剩下容量为1。在01背包中，此时只考虑放物品0，因为物品1已经被用过了，但是在完全背包中，物品可以是无限个，所以此时剩余的容量可以放物品0，也可以放物品1，需要考虑从物品0~1中选择物品放入背包的最大价值，即dp[1][1]，而不是dp[0][1], 所以 放物品1的情况 = dp[1][1] + 物品1的价值
      3. 两种情况，分别是放物品1 和 不放物品1，我们要取最大值,```dp[1][4] = max(dp[0][4], dp[1][4-物品1的容量=1] + 物品1 的价值)```
   2. 不放物品i: 背包容量为j，里面不放物品i的最大价值是dp[i - 1][j]
   3. 放物品i: 背包空出物品i的容量后，背包容量为j - weight[i]，dp[i][j-weight[i]]就是背包重量为j-weight[i]且不放物品i的最大价值，那么dp[i][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值
   递推公式：**dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])**
3. dp数组如何初始化
   **关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**
   1. 首先从dp[i][j]的定义出发，如果j=0，即容量为0，那么无论取哪些物品，都无法放入背包中，背包的总价值一定是0
   2. 根据状态转移方程**dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])**可以看出有一部分的i是由i-1推导出来的，那么i=0就要初始化，即dp[0][j]，当存放物品0的时候，各个容量的背包的最大价值。很明显，当weight[0]>j时，dp[0][j]=0，因为背包容量比物品0重量还小，放不下物品0，当j>=weight[0]时，dp[0][j] 如果能放下weight[0]的话，就一直装，每一种物品有无限个
   ```python
   for j in range(weight[0],bagweight+1): # 正序遍历，如果能放下就一直装物品0
       dp[0][j] = d[0][j-weight[0]]+value[0]
   ```
4. 确定遍历顺序
   1. 先遍历物品，再遍历背包容量
   ```python
   for i in range(1,len(weight)):
       for j in range(bagweight+1):
           if weight[i] > j:
               dp[i][j] = dp[i-1][j]
           else:
               dp[i][j] = max(dp[i-1][j],dp[i][j-weight[i]]+value[i])
   ```
   2. 先遍历背包容量，再遍历物品
   ```python
   for j in range(bagweight+1):
       for i in range(1,len(weight)):
           if weight[i] > j:
               dp[i][j] = dp[i-1][j]
           else:
               dp[i][j] = max(dp[i-1][j],dp[i][j-weight[i]]+value[i])
   ```

## **优化（滚动数组）**：
思考，如果将二维DP数组优化成一维DP数组，就是将上一层拷贝到当前层。
将上一层dp[i-1] 的那一层拷贝到 当前层 dp[i] ，那么 递推公式由：```dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])``` 变成： ```dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])```。因为此时dp[i][j]是空的，还没有计算过，所以dp[i-1][j]不会覆盖dp[i][j]，如果去掉维度i，就变成了1维dp
1. 确定dp数组以及下标的含义
   dp[j]：容量为j的背包，所背的物品价值可以最大为dp[j]，但是一个物品可以无限次使用
2. 确定递推公式
   ```dp[j] = max(dp[j], dp[j - weight[i]] + value[i])```
3. dp数组如何初始化
   dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。
4. 确定遍历顺序
   1. 在01背包中，01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量吗，且为了保证每个物品只使用一次，背包容量需要倒序遍历
   2. 在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！因为dp[j] 是根据下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了，换句话说，更新dp[j]的值需要的是当前状态的dp[j]和当前状态的dp[j-weight[i]],需要的就是更新过的值，所以遍历顺序无所谓。
   ```python
   for i in range(len(weight)): # 遍历物品
       for j in range(bagWeight+1): # 遍历背包容量
           if weight[i] <= j:
               dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

   for j in range(bagWeight+1): # 遍历背包容量
       for i in range(len(weight)): # 遍历物品
           if weight[i] <= j:
               dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
   ```

# 背包问题的组合和排列

1. 组合数的定义
   1. 组合数：指的是只关心物品选取的内容，而不在乎选取的顺序。比如给定物品 [1, 2] 和目标 3，组合方式有：
      1. 用一个 1 和一个 2 （记为 [1, 2] 或 [2, 1] 本质是同一种）
      2. 用三个 1 （记为 [1, 1, 1]）。

2. 排列数的定义
   1. 排列数：不仅关心物品选取的内容，还关心选取的顺序。比如同样是物品 [1, 2] 和目标 3，排列方式有：
      1. [1, 2] 和 [2, 1] 是两种不同的排列方式。
      2. [1,1,1] 也是一种排列。
   
**在动态规划中，循环顺序决定了是否会考虑到顺序的影响**

## **求组合数：外层遍历物品，内层遍历背包**
```python
for i in range(物品):      # 外层遍历物品
    for j in range(target): # 内层遍历背包容量
        dp[j] += dp[j - weight[i]]
```
1. 外层循环的顺序是先固定一个物品，再遍历背包容量。每次遍历到一个容量 j 时，只考虑前 i 个物品的选法。
2. 由于是“先选物品，再扩充组合”，所有物品的选择“顺序”在逻辑上是固定的，不会因为后面物品的加入导致排列方式不同。
3. 举例说明：
   1. 物品：[1, 2]，目标值为 3。
   2. 第一次选 1 后，动态规划会记录所有包含 1 的结果（比如 [1, 2], [1, 1, 1]）。
   3. 后选 2 时，不会把 [2, 1] 当作新的情况，因为之前的 [1, 2] 已经算过了。
4. 因此，最终结果就是组合数。

## **求排列数：外层遍历背包，内层遍历物品**
```python
for j in range(target):   # 外层遍历背包容量
    for i in range(物品):  # 内层遍历物品
        dp[j] += dp[j - weight[i]]
```
1. 外层遍历背包容量，意味着每次针对一个容量，都去尝试用所有物品填充这一容量。
2. 内层遍历物品，在考虑 j 的所有可能组合时会重新尝试每一个物品，使得组合的顺序不同会被全部记录。
3. 举例说明：
   1. 物品：[1, 2]，目标值为 3。
   2. 对于容量 3：先取 1，再取 2，得到 [1, 2]。
   3. 先取 2，再取 1，得到 [2, 1]。
4. 由于“先后顺序”影响了动态规划的推导，排列方式会被完整地保留。

**总结**
1. 循环顺序的不同，是因为动态规划中的状态转移依赖于计算顺序。
   1. 外层循环物品：只计算一种物品选法，确保只记录组合数；
   2. 外层循环背包容量：每次都尝试不同物品选法，导致排列数增加。
2. 如果只需要组合，保证“先选物品”；如果需要排列，则保证“先选容量”。