class Solution:
    def numTrees(self, n: int) -> int:
        # 第一种理解方式
        # dp[i]长度为i的序列可以形成的BST数量
        # 假设1~n的序列以i为根节点，则1~i-1构成左子树，i+1~n构成右子树，次数左子树有i-1个节点，右子树有n-i个节点
        # 此时的dp[i] = dp[i-1]*dp[n-i] 
        # 举例n=100,i=50为根节点，dp(50) = G(49)*G(50)，注意50,49,50这三个数字的含义不同，
        # 第一个50是根节点，第二个49是总数，第三个50还是总数
        # 此时左子树是由1到49这49个数字组成，所以是G(49)
        # 从明面上看G(50)是1-50这50个数组成的数量，但51-100这50个数组成的数量是等价于1-50这50个数字组成的数量的
        # 因为可以将51替换为1，将52替换为2，以此类推下去，所以右子树的数量也是G(50)
        # 所以如果序列长度是n，节点是i，那么左子树有i-1个节点，右子树有n-i个节点
        # base case 0=>空树， 1=>单一节点

        if n <= 1:
            return n 
        dp = [0]*(n+1)
        dp[0] = 1
        dp[1] = 1
        for k in range(2,n+1): # k循环n的每一个数
            for i in range(1,k+1): # i循环当前的数作为根节点
                dp[k] += dp[i-1]*dp[k-i] 
        return dp[-1]
    
class Solution:
    def numTrees(self, n: int) -> int:
        # 第二种理解方式
        # 用i个节点构建数，除去根节点，剩 i−1 个节点构建左、右子树，左子树分配 0 个，则右子树分配到 i−1 个……以此类推。
        # dp[i] = dp[0]*dp[i-1] + dp[1]*dp[i-2]+...+dp[i-1]*dp[0]
        # 若左子树用掉j个，则右子树还剩下i-j-1个, dp[i] = Sum_{i,j} dp[j]*dp[i-j-1], 0<=j<=i-1
        if n <= 1:
            return n 
        dp = [0]*(n+1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2,n+1):
            for j in range(0,i):
                dp[i] += dp[j]*dp[i-j-1]
        return dp[-1]

# 第一种方法：从根节点出发，依次考虑每个节点作为根的情况，计算左右子树的组合数量。
# 第二种方法：通过枚举所有可能的左右子树节点分配情况，计算不同的组合。